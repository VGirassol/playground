import random

def roll_dice(num_dice, num_sides):
    return [random.randint(1, num_sides) for _ in range(num_dice)]

def parse_roll_sequence(sequence):
    rolls = sequence.split('+')
    result = 0
    individual_results = []
    damage_by_type = {'ğŸ—¡': 0, 'âš¡': 0, 'ğŸŒ€': 0, 'ğŸ’€': 0, 'ğŸ”¥': 0, 'ğŸ§ ': 0, 'âš—ï¸': 0}

    for roll in rolls:
        roll = roll.strip()
        num_dice, num_sides = 0, 0

        if 'd' in roll:
            num_dice_part, num_sides_part = roll.split('d')
            num_dice = int(num_dice_part)

            num_sides_part = num_sides_part.split('(')[0].strip()
            num_sides = int(num_sides_part)

            dice_result = roll_dice(num_dice, num_sides)
            result += sum(dice_result)
            individual_results.append(f"{num_dice}d{num_sides}: {dice_result}")

            damage_type = roll.split('(')[-1].split(')')[0]
            if damage_type in damage_by_type:
                damage_by_type[damage_type] += sum(dice_result)
        else:
            if '(' in roll:
                roll, _ = roll.split('(')

            damage_type = roll.split(')')[-1].strip()
            if damage_type == 'ğŸ—¡':
                damage_by_type[damage_type] += int(roll)
            else:
                damage_by_type['ğŸ—¡'] += int(roll)
            result += int(roll)

    return result, individual_results, damage_by_type

def main():
    sequences = [
        "1d8 (ğŸ—¡) + 2d10 (ğŸ§ ) + 2d6 (ğŸŒ€) + 1d6 (ğŸ’€) + 2d8 (ğŸ”¥) + 5 (ğŸ—¡) + 1d4 (ğŸ—¡) + 3 (ğŸ—¡)",
        "1d8 (ğŸ—¡) + 1d6 (ğŸŒ€) + 2d6 (ğŸŒ€) + 1d6 (ğŸ’€) + 2d8 (ğŸ”¥) + 5 (ğŸ—¡) + 1d4 (ğŸ—¡) + 3 (ğŸ—¡)",
        "1d8 (ğŸ—¡) + 2d10 (ğŸ§ ) + 2d6 (ğŸŒ€) + 1d6 (ğŸ’€) + 2d8 (ğŸ”¥) + 5 (ğŸ—¡) + 1d4 (ğŸ—¡) + 3 (ğŸ—¡)",
        "1d4 (ğŸ—¡) + 4d6 (âš¡) + 2d6 (ğŸŒ€) + 1d6 (ğŸ’€) + 2d8 (ğŸ”¥) + 5 (ğŸ—¡) + 1d4 (ğŸ—¡) + 3 (ğŸ—¡)",
        "1d8 (ğŸ—¡) + 2d4 (ğŸŒ€) + 3d6 (âš—ï¸) + 2d6 (ğŸŒ€) + 1d6 (ğŸ’€) + 2d8 (ğŸ”¥) + 5 (ğŸ—¡) + 1d4 (ğŸ—¡)"
    ]

    truques_sequences = {
        "LÃ¢mina em expansÃ£o": "2d6 (ğŸ—¡) + 5",
        "Toque arrepiante": "2d8 (ğŸ’€) + 5",
        "Mordida congelada": "2d6 (ğŸŒ€) + 5",
        "FerrÃ£o da exaustÃ£o": "2d4 (ğŸ’€) + 5"
    }

    while True:
        print("Menu Inicial:")
        print("1. Ataques")
        print("2. ReaÃ§Ãµes")
        print("3. AÃ§Ãµes BÃ´nus")
        print("4. Magias do GrimÃ³rio")
        print("5. Sair")
        choice = input("Escolha uma opÃ§Ã£o (1 a 5): ")

        if choice == '5':
            break
        elif choice == '1':
            print("\nAtaques:")
            print("1. Espada psiÃ´nica")
            print("2. Espada congelada")
            print("3. Adaga relÃ¢mpago")
            print("4. Arco congelado")
            attack_choice = input("Escolha o nÃºmero do ataque (1 a 4) ou 'voltar' para o menu inicial: ")
            
            if attack_choice == 'voltar':
                continue

            attack_index = int(attack_choice) - 1
            if attack_index < 0 or attack_index >= len(sequences):
                print("OpÃ§Ã£o invÃ¡lida.")
                continue

            sequence = sequences[attack_index]
            sequence_name = ["Espada psiÃ´nica", "Espada congelada", "Adaga relÃ¢mpago", "Arco congelado"][attack_index]
            total_result, individual_results, damage_by_type = parse_roll_sequence(sequence)

            print(f"\n{sequence_name}:")
            for individual_result in individual_results:
                print(f"  {individual_result}")

            non_zero_damage_types = [f"{damage} ({symbol})" for symbol, damage in damage_by_type.items() if damage != 0]
            damage_type_str = " + ".join(non_zero_damage_types)

            print(f"  Total por tipo de dano: {damage_type_str}")
            print(f"  Total: {total_result}\n")

        elif choice == '2':
            print("\nReaÃ§Ãµes:")
            print("1. MaldiÃ§Ã£o do Quebrador de FeitiÃ§o")
            print("2. Agulha Prateada")
            print("3. Escudo Arcano")
            print("4. Absorver Elementos")
            reaction_choice = input("Escolha o nÃºmero da reaÃ§Ã£o (1 a 4) ou 'voltar' para o menu inicial: ")
            
            if reaction_choice == 'voltar':
                continue
            
            reaction_index = int(reaction_choice) - 1
            if reaction_index < 0 or reaction_index >= len(reaction_sequences):
                print("OpÃ§Ã£o invÃ¡lida.")
                continue
            
            reaction_sequence = reaction_sequences[reaction_index]
            reaction_name = ["MaldiÃ§Ã£o do Quebrador de FeitiÃ§o", "Agulha Prateada", "Escudo Arcano", "Absorver Elementos"][reaction_index]
            total_result, individual_results, damage_by_type = parse_roll_sequence(reaction_sequence)

            print(f"\n{reaction_name}:")
            for individual_result in individual_results:
                print(f"  {individual_result}")

            non_zero_damage_types = [f"{damage} ({symbol})" for symbol, damage in damage_by_type.items() if damage != 0]
            damage_type_str = " + ".join(non_zero_damage_types)

            print(f"  Total por tipo de dano: {damage_type_str}")
            print(f"  Total: {total_result}\n")

        elif choice == '3':
            print("\nAÃ§Ãµes BÃ´nus:")
            # OpÃ§Ãµes de aÃ§Ãµes bÃ´nus
            print("Em construÃ§Ã£o...")

        elif choice == '4':
            print("\nMagias do GrimÃ³rio:")
            print("1. Truques")
            print("2. Primeiro nÃ­vel")
            print("3. Segundo nÃ­vel")
            spell_level_choice = input("Escolha o nÃ­vel de magia (1 a 3) ou 'voltar' para o menu inicial: ")
            
            if spell_level_choice == 'voltar':
                continue
            
            spell_level_index = int(spell_level_choice) - 1
            if spell_level_index < 0 or spell_level_index >= 3:  # NÃºmero total de nÃ­veis de magia
                print("OpÃ§Ã£o invÃ¡lida.")
                continue
            
            if spell_level_index == 0:
                print("\nMagias do GrimÃ³rio - Truques:")
                while True:
                    print("Escolha um truque:")
                    for index, spell_name in enumerate(truques_sequences.keys(), start=1):
                        print(f"{index}. {spell_name}")
                    print(f"{len(truques_sequences) + 1}. Voltar para o menu inicial")
                    
                    truques_choice = input("Escolha um truque (1 a 6) ou 'voltar': ")
                    
                    if truques_choice == 'voltar':
                        break
                    
                    truques_index = int(truques_choice) - 1
                    if truques_index < 0 or truques_index >= len(truques_sequences):
                        print("OpÃ§Ã£o invÃ¡lida.")
                        continue
                    
                    spell_name = list(truques_sequences.keys())[truques_index]
                    spell_sequence = truques_sequences[spell_name]
                    total_result, individual_results, damage_by_type = parse_roll_sequence(spell_sequence)
                    
                    print(f"\n{spell_name} (Truques):")
                    for individual_result in individual_results:
                        print(f"  {individual_result}")
                    
                    non_zero_damage_types = [f"{damage} ({symbol})" for symbol, damage in damage_by_type.items() if damage != 0]
                    damage_type_str = " + ".join(non_zero_damage_types)
                    
                    print(f"  Total por tipo de dano: {damage_type_str}")
                    print(f"  Total: {total_result}\n")
                
            else:
                # OpÃ§Ãµes de magias de outros nÃ­veis
                print("Em construÃ§Ã£o! Jovem preguiÃ§oso.")

        else:
            print("Escolha uma opÃ§Ã£o vÃ¡lida.")

if __name__ == "__main__":
    main()
